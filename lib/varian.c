/*
 * Copyright (C) 2018 Michael R. Gryk
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <gtk/gtk.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include "varian.h"
#include "cjrutil.h"

/*
 * parseNextToken
 * 
 * This function parses individual fields of a Varian procpar file.  The tokens are generated by the Glib lexical scanner
 *      using the parseProcparTree function.  
 * 
 * How it works:  This function makes use of the Glib lexical scanner: 
 *      https://developer.gnome.org/glib/stable/glib-Lexical-Scanner.html
 *      using the pre-supplied tokens.  The procpar format has ~14 different fields for each parameter in the file.
 *      This function is a giant case switch to handle each token type for each Varian field.  The fields are defined
 *      by procparType.  If the token parses correctly, it is added to the TreeStore and the function returns 0.
 *      If the token does not parse, a GError exception is set and the function returns 1.  The line of the procpar where 
 *      the error occurred is set as the GError code.
 * 
 * To-Do list:
 *      Some procpar fields are custom.  0, 1, 2 rather than int.  It would be a nice feature to still parse an invalid
 *      entry but set a warning for fields which are outside their expected values.
 * 
 * Inputs: Glib lexical scanner: Gscanner;
 *         Gtk Tree Store and Tree Iter;
 *         Number of values and expected enumerated possibilities (from previous fields, set here, or ignored)
 *         Basic type of value (also from a previous field, set here, or ignored).
 *         ProcparType enumeration for possible fields to parse
 *         GError for error callbacks.  The error code reports the line number of the parse error
 * Output: 0 (success) or 1 (failure).  If 1, GError should not be NULL.
 */

int parseNextToken (GScanner *scanner, GtkTreeStore *store, GtkTreeIter *iter, int *numValues, int *enumValues, int *basicType, int procparType, GError **error) {
    
    /*
     *  Varian basictype: 0 (undefined), 1 (real), 2 (string)
     */
    
    int negate = 1;
    char numberToString[32];
    GValue *enumValue;
    gchar *fullEnumString;
    
    g_scanner_get_next_token(scanner);
    switch (procparType){
        case PP_NAME :
            if (scanner->token == G_TOKEN_IDENTIFIER) {
                gtk_tree_store_insert(store, iter, NULL, -1);       // New row for tree
                gtk_tree_store_set(store, iter, procparType, (char *) scanner->value.v_identifier, -1);
                gtk_tree_store_set(store, iter, PP_ENUMVALUE, "", -1);
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid parameter name: line %d", scanner->line); 
                return 1; 
            }
        case PP_SUBTYPE    :
        case PP_GGROUP     :
        case PP_DGROUP     :
        case PP_PROTECTION :
        case PP_ACTIVE     :
        case PP_INTPTR     :
            if (scanner->token == G_TOKEN_INT) {
                gtk_tree_store_set(store, iter, procparType, (int) scanner->value.v_int, -1);
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Expected Integer: line %d, character %d", scanner->line, scanner->position); 
                return 1; 
            }
        case PP_BASIC_TYPE :
            if (scanner->token == G_TOKEN_INT) {
                gtk_tree_store_set(store, iter, procparType, (int) scanner->value.v_int, -1);
                (*basicType) = scanner->value.v_int;
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid basictype: line %d", scanner->line); 
                return 1; 
            }
        case PP_MAX :
            scanner->config->int_2_float = TRUE;
            if (scanner->token =='-') {
                negate = -1;
                g_scanner_get_next_token(scanner);
            }
            if (scanner->token == G_TOKEN_FLOAT) {
                gtk_tree_store_set(store, iter, procparType, (float) negate*(scanner->value.v_float), -1);
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid Maximum Value: line %d, character %d", scanner->line, scanner->position); 
                return 1; 
            }
        case PP_MIN :
        case PP_STEP_SIZE :
            if (scanner->token =='-') {
                negate = -1;
                g_scanner_get_next_token(scanner);
            }
            if (scanner->token == G_TOKEN_FLOAT) {
                gtk_tree_store_set(store, iter, procparType, (float) negate*(scanner->value.v_float), -1);
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid Min/StepSize: line %d, character %d", scanner->line, scanner->position); 
                return 1; 
            } 
        case PP_NUM_VALUES :
            if (scanner->token == G_TOKEN_INT) {
                (*numValues) = scanner->value.v_int;
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid number of values: line %d", scanner->line); 
                return 1; 
            }
        case PP_ENUMS :
            if (scanner->token == G_TOKEN_INT) {
                (*enumValues) = scanner->value.v_int;
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid number of enumerated values: line %d", scanner->line); 
                return 1; 
            }
        case PP_VALUE :
            if (scanner->token =='-') {
                negate = -1;
                g_scanner_get_next_token(scanner);
            } 
            if ((scanner->token == G_TOKEN_INT) && (*basicType < 2)) {
                sprintf(numberToString, "%d", ((int) scanner->value.v_int)*negate);
                gtk_tree_store_set(store, iter, procparType, numberToString, -1);
                return 0;
            } else if ((scanner->token == G_TOKEN_FLOAT) && (*basicType < 2)) {
                sprintf(numberToString, "%f", ((double) scanner->value.v_float)*negate);
                gtk_tree_store_set(store, iter, procparType, numberToString, -1);
                return 0;
            } else if ((scanner->token == G_TOKEN_STRING) && (*basicType == 2)) {             
                gtk_tree_store_set(store, iter, procparType, (char *) scanner->value.v_string, -1);
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid Value: line %d", scanner->line); 
                return 1; 
            }
        case PP_ENUMVALUE :     // Enumerated values must be strings!!
            if ((scanner->token == G_TOKEN_STRING) && (*basicType == 2)) { 
                gtk_tree_model_get(GTK_TREE_MODEL(store), iter, PP_ENUMVALUE, &fullEnumString, -1);
                /*
                 * This if statement concatenates all enumValues into one csv string.  If want tree, remove if and else.
                 */
                if (strcmp(fullEnumString,"") == 0)
                gtk_tree_store_set(store, iter, procparType, scanner->value.v_string, -1);
                else gtk_tree_store_set(store, iter, procparType, 
                                    concatManyStrings(3,fullEnumString,",",scanner->value.v_string), -1); 
                gtk_tree_model_get(GTK_TREE_MODEL(store), iter, PP_ENUMVALUE, &fullEnumString, -1);
            //    printf("%s\n", fullEnumString);
                g_free(fullEnumString);
                return 0;
            } else { 
                g_set_error(error, CJR_PARSE_ERROR, scanner->line, "Invalid Enumerated Value: line %d", scanner->line); 
                return 1; 
            }
    }
}

/*
 * parseProcparTree
 * 
 * This function parses Varian procpar parameters into a GtkTreeStore structure.  The Varian file format is 
 *      essentially a tree structure, as there can be multiple values for a parameter (the first digit on the 2nd line)
 *      as well as multiple enumerated possibilities for the value (the first digit on the last line).  This is the tree
 *      defined by the procpar format.
 * There are additional tree possibilities.  Some procpar values are comma or semi-colon deliminated strings.  These 
 *      could be further parsed as child values of the parent parameter.  This parser function DOES NOT attempt to do this.
 *      Only the multiple value defined by the format are allocated to separate leaves of the tree.
 * In fact, for the purposes of display, the enumerated values are a distraction and this function
 *      concatenates those leaves into one, comma-separated string.  (Sloppy code alert: always start with leading comma)
 * 
 * How it works:  This function makes use of the Glib lexical scanner: 
 *      https://developer.gnome.org/glib/stable/glib-Lexical-Scanner.html
 *      using the pre-supplied tokens.  The procpar format has ~14 different elements for each parameter in the file.
 *      The GtkTreeStore is initialized with those elements and the procpar string is fed into the scanner.
 *      Numbers are converted to ints (so that 0 is not considered binary), and strings are defined with double quotes.
 *      The scanner proceeds token by token calling the parseNextToken function for handling the valid/invalid fiels.
 *      Two idiosyncracies with numbers.  Some procpar floats have no decimal point and so int2float must be set.
 *      Also, a negative sign is a separate token and is handled in the parseNextToken function.
 * 
 * To-Do list:
 *      Some procpar fields are custom.  0, 1, 2 rather than int.  It would be a nice feature to still parse an invalid
 *      entry but set a warning for fields which are outside their expected values.
 * 
 * Inputs: procpar file (loaded into a string);
 *         GError for error callbacks.  The error code reports the line number of the parse error
 * Output: A GtkTreeStore for the procpar parameters.  If GError is not null, this will be partial up to the parse error.
 */

GtkTreeStore *parseProcparTree(char *procparString, GError **error)
{
    GtkTreeStore *store;
    GtkTreeIter iterParent, iterChild;
    GScanner *scanner;
    int numValues = 0, numEnumValues = 0;
    char testString[] = "ins 3 1 8190 0 1e-07 4 1 3 1 64\n1 1 \n0 \ndownsamp 7 1 999 1 1 3 1 1 0 64\n1 0 \n0 ";
//    GQuark CJR_PARSE_ERROR = g_quark_from_string("CONNJUR Parse Error");
    int i, basictype = 0;

    store = gtk_tree_store_new(13, 
            G_TYPE_STRING,              // parameter name
            G_TYPE_STRING,              // parameter value  This value is out of order from procpar for display purposes
            G_TYPE_INT,                 // subtype
            G_TYPE_INT,                 // basictype
            G_TYPE_FLOAT,               // maximum value
            G_TYPE_FLOAT,               // minimum value
            G_TYPE_FLOAT,               // step size
            G_TYPE_INT,                 // Ggroup
            G_TYPE_INT,                 // Dgroup
            G_TYPE_INT,                 // protection
            G_TYPE_INT,                 // active flag
            G_TYPE_INT,                 // intptr  (unused)
            G_TYPE_STRING);             // enumerated values
   
    scanner = g_scanner_new(NULL);
    scanner->config->numbers_2_int = TRUE;
    scanner->config->scan_string_dq = TRUE;
    g_scanner_input_text (scanner, procparString, strlen (procparString));
    
    g_scanner_peek_next_token (scanner);
    while (scanner->next_token != G_TOKEN_EOF) {
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_NAME, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_SUBTYPE, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_BASIC_TYPE, error)) break;
        scanner->config->int_2_float = TRUE;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_MAX, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_MIN, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_STEP_SIZE, error)) break;
        scanner->config->int_2_float = FALSE;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_GGROUP, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_DGROUP, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_PROTECTION, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_ACTIVE, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_INTPTR, error)) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_NUM_VALUES, error)) break;
        for (i = 0; i < numValues; i++) {
            if (i == 0) {
                if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_VALUE, error)) break;
            }
            else {
                gtk_tree_store_insert(store, &iterChild, &iterParent, -1);
                if (parseNextToken (scanner, store, &iterChild, &numValues, &numEnumValues, &basictype, PP_VALUE, error)) break;
            }
        }
        if (*error != NULL) break;
        if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_ENUMS, error)) break;
        for (i = 0; i < numEnumValues; i++) {
            /*
             *  These series of lines are commented out so that the enumValues are not allocated to tree children
             *      Instead, they are all sent to the same parent row and concatenated by parseNextToken
             *      Comment them back in to build tree, but fix parseNextToken as well
             */
        //    if (i == 0) {
                if (parseNextToken (scanner, store, &iterParent, &numValues, &numEnumValues, &basictype, PP_ENUMVALUE, error)) break;
        //    }
        //    else {
        //        gtk_tree_store_insert(store, &iterChild, &iterParent, -1);    // Commented out for no enum children in tree
        //        if (parseNextToken (scanner, store, &iterChild, &numValues, &numEnumValues, &basictype, PP_ENUMVALUE, error)) break;
        //    }
        }
        if (*error != NULL) break;
        g_scanner_peek_next_token (scanner);
    }
    g_scanner_destroy(scanner);    
    return(store);
}